"use strict";(self.webpackChunk_callstack_byorg_docs=self.webpackChunk_callstack_byorg_docs||[]).push([["887"],{6494:function(e,n,s){s.r(n),s.d(n,{default:function(){return d}});var r=s(651),t=s(6971);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",ul:"ul",li:"li",code:"code",pre:"pre"},(0,t.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"plugins",children:["Plugins",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#plugins",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Plugins allow you to modify the context before it reaches the inference and AI response phase. Each plugin consists of a name, optional middleware, and optional effects."}),"\n",(0,r.jsxs)(n.h2,{id:"middleware-and-effects",children:["Middleware and Effects",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#middleware-and-effects",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"While middleware and effects share some similarities, they serve different purposes within the framework:"}),"\n",(0,r.jsxs)(n.h3,{id:"middleware",children:["Middleware",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#middleware",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A middleware function receives the request context and an asynchronous ",(0,r.jsx)(n.code,{children:"next()"})," function, which triggers the next middleware in the chain."]}),"\n",(0,r.jsxs)(n.li,{children:["Middleware can execute code before and after receiving the final response from the chat model:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Code before the ",(0,r.jsx)(n.code,{children:"await next()"})," call runs prior to receiving the chat model's response."]}),"\n",(0,r.jsxs)(n.li,{children:["Code after the ",(0,r.jsx)(n.code,{children:"await next()"})," call runs after the chat model's response is received."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Middleware execution blocks the final response from being sent to the user. To avoid delaying the user response, use effects instead."}),"\n",(0,r.jsx)(n.li,{children:"Partial responses (enabled via the onPartialResponse option) are streamed immediately as they are received from the chat model. These occur before the middleware code that runs after the await next() call."}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"effects",children:["Effects",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#effects",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"An effect function received the request context and the final response sent to the user."}),"\n",(0,r.jsx)(n.li,{children:"Effects are executed after the message processing pipeline has completed."}),"\n",(0,r.jsx)(n.li,{children:"Use effects for tasks like logging, analytics, or other post-processing operations that do not block the user response."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Note that the response to the user is blocked until all middlewares finish processing."}),"\n",(0,r.jsxs)(n.h2,{id:"middleware-example",children:["Middleware Example",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#middleware-example",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Let's create a middleware that enriches the context for our system prompt function."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { ApplicationPlugin, MessageResponse } from '@callstack/byorg-core';\n\nconst isAdminPlugin: Promise<MessageResponse> = {\n  name: 'is-admin',\n  middleware: async (context, next): Promise<MessageResponse> => {\n    const isAdmin = await checkIfUserIsAdmin(context.lastMessage.senderId)\n\n    context.extras.isAdmin = isAdmin;\n\n    // Continue middleware chain\n    return next();\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"effect-example",children:["Effect example",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#effect-example",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Now, let's create an effect that runs after receiving a response from the AI. If the user is an admin or the response ends with an error, it does nothing. Otherwise, it increases the message count for the user."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { MessageResponse } from '@callstack/byorg-core';\n\nconst usageCountPlugin: Promise<MessageResponse> = {\n  name: 'usage-count',\n  effects: [counterEffect]\n};\n\nasync function counterEffect(context: RequestContext, response: MessageResponse): Promise<void> {\n  const { isAdmin } = context.extras;\n\n  if(response.error || isAdmin) {\n    return;\n  }\n\n  await increaseMsgsCount(context.lastMessage.userId)\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"connecting-plugins",children:["Connecting Plugins",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#connecting-plugins",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Once you've written your plugins, connect them to the app:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"  const app = createApp({\n    chatModel,\n    plugins: [\n      usageCountPlugin,\n      isAdminPlugin\n    ]\n    systemPrompt,\n  });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The order of plugins is important! Depending on the call to ",(0,r.jsx)(n.code,{children:"next"}),", they are executed:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Top-down before the call to ",(0,r.jsx)(n.code,{children:"next"})]}),"\n",(0,r.jsxs)(n.li,{children:["Bottom-up after the call to ",(0,r.jsx)(n.code,{children:"next"})]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"midleware-early-return",children:["Midleware early return",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#midleware-early-return",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"Your middleware can also break the execution chain early, stopping the execution of any subsequent middleware."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"import { ApplicationPlugin, MessageResponse } from '@callstack/byorg-core';\n\nconst flowBreakingPlugin: Promise<MessageResponse> = {\n  name: 'breaks-flow',\n  middleware: async (context, next): Promise<MessageResponse> => {\n    // Breaks the middleware chain\n    return {\n      role: 'system';\n      content: \"AI Assistant is unvailable now!\";\n    };\n  },\n};\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"pending-effects",children:["Pending effects",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#pending-effects",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["When you trigger ",(0,r.jsx)(n.code,{children:"processMessages"})," on a byorg app, one of the returned values is ",(0,r.jsx)(n.code,{children:"pendingEffects"}),".\nThis allows you to wait for them to finish execution, which is useful to prevent the application from shutting down prematurely (e.g., in serverless functions)."]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let d=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["docs%2Fcore%2Fplugins.md"]={toc:[{text:"Middleware and Effects",id:"middleware-and-effects",depth:2},{text:"Middleware",id:"middleware",depth:3},{text:"Effects",id:"effects",depth:3},{text:"Middleware Example",id:"middleware-example",depth:2},{text:"Effect example",id:"effect-example",depth:2},{text:"Connecting Plugins",id:"connecting-plugins",depth:2},{text:"Midleware early return",id:"midleware-early-return",depth:2},{text:"Pending effects",id:"pending-effects",depth:2}],title:"Plugins",headingTitle:"Plugins",frontmatter:{}}}}]);